Object relational mapping
- ORM atau singkatan dari Object Relational Mapping, adalah teknik untuk memetakan data dari database relational ke dalam object dalam pemrograman
- ketika kita belajar golang database, kita belajar pattern bernama repository, yang digunakan sebagai jembatan komunikasi ke database
- saat membuat repository, kita membuat struct entity sebagai representasi dari tabel di database
- hal itu sebenarnya sudah bisa dibilang sebuah ORM, namun masih dilakukan secara manual

GORM
- GORM adalah satu library untuk implementasi ORM secara otomatis di golang
- dengan menggunakan GORM, kita bisa fokus membuat pemetaan struct entity, tanpa harus memikirkan detail dari implementasi SQL yang harus kita buat untuk memanipulasi datanya
- GORM juga mendukung relasi antar entity / table, baik itu one to one, one to many, sampai many to many
- referensi : https://gorm.io/

install library :
- testify : go get github.com/stretchr/testify
- assert : go get github.com/stretchr/testify/assert
- install library yang kurang : go mod tidy (optional)
- gorm : go get gorm.io/gorm
- gorm mysql (hanya untuk mysql) : go get gorm.io/driver/mysql

database connection
- hal pertama yang perlu kita lakukan sebelum menggunakan GORM, adalah membuat koneksi ke database
- gunakan database yang sesuai dengan yang kita gunakan
- untuk membuat koneksi ke database, kita bisa gunakan function gorm.Open()
- tiap jenis database memiliki config masing-masing, kita bisa lihat konfigurasinya di referensi berikut ini : https://gorm.io/docs/connecting_to_the_database.html

raw SQL
- Raw SQL artinya membuat query SQL secara manual
- terdapat 2 jenis sql, untuk melakukan query (select), atau untuk mengubah data (insert, update, delete)
- untuk melakukan query (select data), kita bisa menggunakan method Raw(sql) di gorm.DB
- dan untuk melakukan manipulasi data, bisa gunakan method Exec(sql) di gorm.DB

sql.Row dan sql.Rows
- GORM sendiri sebanarnya di dalamnya tetap menggunakan package sql bawaan dari golang
- jika kita ingin mendapatkan hasil query dalam bentuk sql.Rows, kita bisa menggunakan method Rows() setelah melakukan query

model
- model atau entity adalah struct representasi dari tabel di database
- saat membuat tabel di database, direkomendasikan dibuatkan struct sebagai representasinya
- hal ini agar kita tidak perlu melakukan pembuatan perintah SQL secara manual lagi

convention
- saat membuat struct, secara default GORM akan melakukan mapping secara otomatis dimana nama tabel akan dipilih dari nama struct menggunakan lower_case jamak (contoh tabel 'OrderDetail', maka akan menjadi 'order_details'), sedangkan nama kolom akan dipilih menggunakan lower_case
- selain itu, secara otomatis GORM akan memilih field ID sebagai primary key
- namun, sebenarnya disarankan dibanding dilakukan secara otomatis menggunakan GORM, lebih bnaik kita deklarasikan secara manual menggunakan tag
- referensi : https://gorm.io/docs/models.html#Fields-Tags

table name
- secara default, nama tabel akan menggunakan lower_case dan jamak (sifatnya lebih dari satu)
- misal struct User akan menggunakan tabel users
- misal lagi struct OrderDetail akan menggunakan nama tabel order_details
- namun jika kita ingin menggunakan manual nama tabelnya, kita bisa menggunakan interface Tabler, yang mewajibkan untuk membuat method dengan nama TableName()

model conventions
- saat kita membuat struct untuk model, jika kita mengikuti aturan GORM, sebenarnya kita tidak perlu menggunakan tag

Id sebagai primary key
- GORM secara default menggunakan field ID sebagai primary key
- jika kita membuat field ID di struct model, secara default akan digunakan sebagai primary key di tabel tersebut
- jika kita ingin memilih field lain selain ID, maka kita harus menggunakan tag gorm:"primaryKey"

Table Name
- GORM secara default akan menggunakan nama tabel dengan format snake_cases (lowercase menggunakan '_' (underscore) sebagai pemisah, dan dijadikan jamak)
- misal untuk stuct User, secara default akan menggunakan nama tabel 'users'
- untuk struct OrderDetail, secara default akan menggunakan nama tabel 'order_details'
- jika kita ingin mengubah nama default tabel nya, maka kita harus implementasi interface Tabler dengan menambahkan method TableName()

Column Name
- GORM secara default akan menggunakan snake_case untuk nama kolom dari struct model yang kita buat
- misal jika field ID artinya nama kolomnya adalah 'id'
- jika field FirstName artinya nama kolomnya adalah 'first_name'
jika kita ingin mengubah nama kolom, kita bisa menggunakan tag gorm:"column:nama_kolom_baru"

Timestamp Tracking
- GORM memilik fitur timestamp tracking, yaitu melakukan perubahan otomatis untuk waktu dibuat dan diubah nya model menggunakan field CreatedAt dan UpdatedAt
- CreatedAt dan UpdatedAt secara default akan menggunakan time.Now() ketika dibuat
- UpdatedAt akan selalu diubah menjadi time.Now() ketika diupdate datanya
- jika kita ingin mengubah nama field nya, kita bisa tambahkan gorm:"autoCreateTime:true" untuk CreatedAt
- dan menggunakan gorm:"autoUpdateTime:true" untuk UpdatedAt

field permission
- secara default, semua field di struct model akan dianggap kolom di table
- dan semua perubahan di field, akan di update ke tabel di database
- namun, kadang-kadang mungkin kita ingin membuat field yang tidak merepresentasikan kolom di tabel sehingga tidak perlu create / update
- atau mungkin terdapat kolom yang tidak perlu di update lagi
- untuk mendukung kasus seperti itu, GORM menyediakan field permission menggunakan tag gorm

    Tag     |   Keterangan
-----------------------------------------------------------------------------------------------------------------------------
    <-      |   Write permissio. <-:create (untuk create only), <-:update (untuk update only), <- (untuk create dan update)
    ->      |   Read permission. ->:false (untuk no read permission/tidak boleh dibaca)
    -       |   ignore field ini, tidak ada read/write permission

embedded struct
- secara default, field di model akan menjadi kolom tabel, kecuali yang menggunakan '-' (field permission ignore)
- namun, bagaimana jika ternyata field yang kita buat sangat banyak?
- kadang-kadang, ada baiknya kita simpan field yang sejenis dalam struct yang berbeda
- untungnya, GORM memiliki fitur bernama embedded struct, dimana kita bisa melakukan embed struct dalam field di model, sehingga seluruh isi field di embedded struct akan dianggap field di model utamanya
- misal, kita akan tambahkan kolom first_name, middle_name, dan last_name pada tabel users
- lalu kita akan buat dalam embedded struct Name
- kita bisa gunakan tag gorm:"embedded" untuk emnandai sebagai embedded struct

create
- untuk memasukkan data ke database, kita tidak perlu membuat SQL insert secara manual 
- GORM bisa membaca data dari model yang sudah kita buat, lalu secara otomatis akan membuat perintah SQL sesuai dengan data model yang kita buat
- kita bisa menggunakan method Create() pada gorm.DB

batch insert
- saat kita menggunakan Create() method, maka tiap data akan dibuatkan SQL insert
- kadang ketika kita ingin memasukkan banyak data sekaligus, ada baiknya kita menggunakan sekali SQl insert agar lebih efektif
- GORM mendukung hal ini menggunakan method Create(slices), atau jika ingin menentukan jumlah data per SQL insert, kita bisa gunakan CreateInBatches(slices, size)

logger
- secara default, informasi perintah SQL yang dieksekusi oleh GORM tidak akan di log
- kita bisa mengubah level log dari GORM menggunakan gorm.Config{} ketika membuat koneksi database

transaction
- transaction hanya bisa terjadi jika kita menggunakan database connection yang sama
- saat kita menggunakan method di gorm.DB, bisa saja tiap method akan menggunakan database connection yang berbeda, karena connection pool nya diatur oleh GORM
- jika kita ingin melakukan transaction, kita bisa menggunakan method Transaction(callback), dan di dalam function callback kita bisa buat semua kode transaction nya

manual transaction
- selain menggunakan method Transaction(callback), kita juga bisa melakukan manajemen transaksi secara manual (tidak direkomendasikan jika sudah menggunakan gorm)
- kita bisa membuat object gorm.DB ketika menjalankan transaksi dengan method Begin()
- ketika ingin melakukan commit, kita bisa menggunakan method Commit()
- ketika ingin melakukan rollback, kita bsia menggunakan method Rollback()

query 
- sama dengan Create(), GORM juga bisa secara otomatis membuat SQL SELECT dari model yang kita buat
- sehingga tidak perlu lagi membuat SQL select secara manual

single object
- GORM menyediakan beberapa method untuk mengambil single object dari database
- First() : digunakan untuk mengambil data pertama yang diurutkan berdasarkan id
- Take() : digunakan untuk mengambil satu data, tanpa di urutkan
- Last() : digunakan untuk mengambil data terakhir yang diurutkan berdasarkan id
- jika data tidak ditemukan, maka akan error gorm.ErrRecordNotFound

inline condition
- saat kita menggunakan method First, Take atau Last, terdapat parameter selanjutnya bernama inline condition
- inline condition tersebut secara otomatis akan menjadi kondisi WHERE di SQL SELECT nya

query all objects
- GORM juga bisa digunakan untuk melakukan QUERY pada semua data di tabel menggunakan method Find()
- sama seperti method sebelumnya, method Find() juga mendukung inline condition jika kita mau tambahkan kondisi WHERE nya

query condition
- sebelumnya kita sudah bisa menggunakan inline parameter ketika melakukan query
- selain menggunakan inline parameter, kita juga bisa menggunakan method Where() untuk mengubah kondisi query yang akan kita buat

or condition
- secara default saat kita menggunakan Where(), kondisi akan digabung menggunakan AND operator 
- jika kita ingin menggunakan OR operator, kita bisa menggunakan method OR()

not condition
- dan jika kita ingin menggunakan NOT operator, kita bisa menggunakan method NOT()

select Fields
- secara default, semua kolom akan di select dan dimasukkan ke field Model
- jika misal kita ingin menentukan kolom apa saja yang mau di select, kita bisa menggunakan method Select(columns)

struct & map condition
- saat kita menggunakan Where(), Not(), dan Or(). Kita juga bisa menggunakan parameter struct atau map
- secara otomatis field atau key dijadikan kolom query, dan value akan dijadikan value query
- ini cocok ketika pada kasus kita butuh query yang dinamis, sehingga kolom yang dicari bisa berbeda-beda sesuai kondisi pencarian

order, limit dan offset
- untuk melakukan sorting, kita juga bisa menggunakan method Order()
- dan untuk melakukan paging, kita bsia menggunakan method Limit() dan Offset()

query non model
- saat kita menggunakan First(), Take(), Last() dan Find(), GORM melihat struktur tabel ke model yang kita gunakan
- namun GORM memiliki fitur untuk menyimpan data (hasil query) ke data yang bukan model, contoh kita hanya ingin melakukan query first_name dan last_name saja di tabel users misalnya. kita bisa membuat struct berbeda dibanding menggunakan model users
- jika kita ingin melakukan hal ini, GORM tetap harus tahu, model mana yang digunakan, caranya adalah kita bisa menggunakan method Model() untuk menentukan model yang digunakan

update
- untuk melakukan update data model yang sudah dimodifikasi, kita bisa menggunakan method Save() di gorm.DB
- secara otomatis semua kolom yang memang memiliki permission untuk di update, akan di update ke database

update selected column
- secara default, melakukan Save() untuk data model, akan melakukan update semua kolom, walaupun tidak melakukan perubahan sebelumnya
- jika kita ingin menentukan hanya beberapa kolom yang ingin di update, kita bisa menggunakan method Updates()
- atau menggunakan method Update(kolom, value) jika hanya ingin update satu kolom saja

auto increment
- salah satu fitur yang biasa ada database adalah Auto Increment untuk primary key
- contoh di Mysql ada AUTO_INCREMENT, atau di PostgreSQL ada SERIAL
- GORM mendukung pembuatan ID yang auto increment, dan secara otomatis akan melakukan query data ID (data terakhir di database) setelah kita Create() datanya, sehingga tidak perlu melakukan query manual lagi
- untuk memberi tahu bahwa field adalah auto_increment, kita harus menggunakan tag gorm:"autoIncrement"

timestamp tracking
- GORM menggunakan field CreatedAt dan UpdatedAt sebagai timestamp tracking
- atau jika ingin menggunakan field yang berbeda, kita bisa tambahkan tag gorm:"autoCreateTime" atau gorm:"autoUpdateTime"

tipe data timestamp tracking
- sebelumnya kita menggunakan tipe data time.Time sebagai field untuk timestamp tracking 
- namun, sebenarnya kita juga bisa ubah tipe datanya jika kita mau
- GORM mendukung tipe data dalam bentuk number, dimana satuannya bisa kita ganti menjadi mili untuk mili second, atau nano untuk nano second, semuanya disimpan dalam waktu epoch unix time
- misal tag gorm:"autoCreateTime:mili" atau gorm:"autoUpdateTime:mili"
- referensi : https://currentmillis.com/

upsert 
- sebelumnya, kita telah menggunakan method Save() untuk melakukan update
- method Save(), sebenarnya memiliki kemampuan untuk mendeteksi apakah harus melakukan Update atau Create
- jika data yang kita kirim tidak memiliki value ID, maka secara default akan melakukan Create
- jika data yang kira kirim memiliki value ID, maka akan melakukan Update
- hal ini mungkin cocok untuk jenis data yang ID nya adalah Auto Increment, karena kita tidak butuh ID ketika melakukan create

upsert : data non auto increment
- untungnya, Save() juga bisa digunakan untuk proses otomatis Create
- jadi Save() akan mencoba melakukan update terlebih dahulu, ketika mendeteksi jumlah effectedRow nya adalah 0, secara otomatis method Save() akan melakukan proses Create

on conflict
- GORM juga menawarkan pengaturan conflict di method Create()
- dengan pengaturan ini, kita bisa menentukan ketika kita coba Create() data, lalu terjadi conflict (data sudah ada), apa yang mau kita lakukan?
- kita bisa mengubah pengaturan conflict ini menggunakan method Clauses()

delete
- untuk melakukan penghapusan data, kita bisa menggunakan method Delete()
- method Delete() juga mendukung Inline Condition atau menggunakan Where() method

soft delete
- soft delete adalah salah satu praktek yang sering dilakukan ketika membuat aplikasi
- soft delete merupakan praktek menghapus data, tanpa menghapus data dari database
- praktek ini membuat satu kolom biasanya berupa tipe data timestamp yang berisi waktu dihapus 
- jika kolom tersebut berisi data, otomatis data tersebut dianggap sudah di delete

GORM soft delete
- GORM mendukung fitur Soft Delete secara otomatis, caranya kita cukup membuat field DeletedAt dengan time gorm.DeletedAt (alias untuk time.Time)
- jika GORM mendeteksi terdapat field dengan nama DeletedAt, secara otomatis GORM akan melakukan soft delete
- selain itu, ketika melakukan query, secara otomatis juga GORM akan menambah filter soft delete, yang artinya hasil query hanya data yang belum di delete

unscoped
- ketika kita ingin mengambil data yang termasuk ke dalam soft delete, kita bisa gunakan method Unscoped()
- method Unscoped() juga bisa digunakan jika kita benar benar mau melakukan hard delete data secara permanen di database

soft delete - peringatan
- saat menggunakan soft delete, perhatikan penggunaan primary key atau unique index
- ketika data sudah dihapus secara soft delete, sebenarnya data masih ada di tabel, oleh karena itu pastikan primary key atau unique index tidak duplikat dengan data yang sudah dihapus secara soft delete
