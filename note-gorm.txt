Object relational mapping
- ORM atau singkatan dari Object Relational Mapping, adalah teknik untuk memetakan data dari database relational ke dalam object dalam pemrograman
- ketika kita belajar golang database, kita belajar pattern bernama repository, yang digunakan sebagai jembatan komunikasi ke database
- saat membuat repository, kita membuat struct entity sebagai representasi dari tabel di database
- hal itu sebenarnya sudah bisa dibilang sebuah ORM, namun masih dilakukan secara manual

GORM
- GORM adalah satu library untuk implementasi ORM secara otomatis di golang
- dengan menggunakan GORM, kita bisa fokus membuat pemetaan struct entity, tanpa harus memikirkan detail dari implementasi SQL yang harus kita buat untuk memanipulasi datanya
- GORM juga mendukung relasi antar entity / table, baik itu one to one, one to many, sampai many to many
- referensi : https://gorm.io/

install library :
- testify : go get github.com/stretchr/testify
- assert : go get github.com/stretchr/testify/assert
- install library yang kurang : go mod tidy (optional)
- gorm : go get gorm.io/gorm
- gorm mysql (hanya untuk mysql) : go get gorm.io/driver/mysql

database connection
- hal pertama yang perlu kita lakukan sebelum menggunakan GORM, adalah membuat koneksi ke database
- gunakan database yang sesuai dengan yang kita gunakan
- untuk membuat koneksi ke database, kita bisa gunakan function gorm.Open()
- tiap jenis database memiliki config masing-masing, kita bisa lihat konfigurasinya di referensi berikut ini : https://gorm.io/docs/connecting_to_the_database.html

raw SQL
- Raw SQL artinya membuat query SQL secara manual
- terdapat 2 jenis sql, untuk melakukan query (select), atau untuk mengubah data (insert, update, delete)
- untuk melakukan query (select data), kita bisa menggunakan method Raw(sql) di gorm.DB
- dan untuk melakukan manipulasi data, bisa gunakan method Exec(sql) di gorm.DB

sql.Row dan sql.Rows
- GORM sendiri sebanarnya di dalamnya tetap menggunakan package sql bawaan dari golang
- jika kita ingin mendapatkan hasil query dalam bentuk sql.Rows, kita bisa menggunakan method Rows() setelah melakukan query

model
- model atau entity adalah struct representasi dari tabel di database
- saat membuat tabel di database, direkomendasikan dibuatkan struct sebagai representasinya
- hal ini agar kita tidak perlu melakukan pembuatan perintah SQL secara manual lagi

convention
- saat membuat struct, secara default GORM akan melakukan mapping secara otomatis dimana nama tabel akan dipilih dari nama struct menggunakan lower_case jamak (contoh tabel 'OrderDetail', maka akan menjadi 'order_details'), sedangkan nama kolom akan dipilih menggunakan lower_case
- selain itu, secara otomatis GORM akan memilih field ID sebagai primary key
- namun, sebenarnya disarankan dibanding dilakukan secara otomatis menggunakan GORM, lebih bnaik kita deklarasikan secara manual menggunakan tag
- referensi : https://gorm.io/docs/models.html#Fields-Tags

table name
- secara default, nama tabel akan menggunakan lower_case dan jamak (sifatnya lebih dari satu)
- misal struct User akan menggunakan tabel users
- misal lagi struct OrderDetail akan menggunakan nama tabel order_details
- namun jika kita ingin menggunakan manual nama tabelnya, kita bisa menggunakan interface Tabler, yang mewajibkan untuk membuat method dengan nama TableName()

model conventions
- saat kita membuat struct untuk model, jika kita mengikuti aturan GORM, sebenarnya kita tidak perlu menggunakan tag

Id sebagai primary key
- GORM secara default menggunakan field ID sebagai primary key
- jika kita membuat field ID di struct model, secara default akan digunakan sebagai primary key di tabel tersebut
- jika kita ingin memilih field lain selain ID, maka kita harus menggunakan tag gorm:"primaryKey"

Table Name
- GORM secara default akan menggunakan nama tabel dengan format snake_cases (lowercase menggunakan '_' (underscore) sebagai pemisah, dan dijadikan jamak)
- misal untuk stuct User, secara default akan menggunakan nama tabel 'users'
- untuk struct OrderDetail, secara default akan menggunakan nama tabel 'order_details'
- jika kita ingin mengubah nama default tabel nya, maka kita harus implementasi interface Tabler dengan menambahkan method TableName()

Column Name
- GORM secara default akan menggunakan snake_case untuk nama kolom dari struct model yang kita buat
- misal jika field ID artinya nama kolomnya adalah 'id'
- jika field FirstName artinya nama kolomnya adalah 'first_name'
jika kita ingin mengubah nama kolom, kita bisa menggunakan tag gorm:"column:nama_kolom_baru"

Timestamp Tracking
- GORM memilik fitur timestamp tracking, yaitu melakukan perubahan otomatis untuk waktu dibuat dan diubah nya model menggunakan field CreatedAt dan UpdatedAt
- CreatedAt dan UpdatedAt secara default akan menggunakan time.Now() ketika dibuat
- UpdatedAt akan selalu diubah menjadi time.Now() ketika diupdate datanya
- jika kita ingin mengubah nama field nya, kita bisa tambahkan gorm:"autoCreateTime:true" untuk CreatedAt
- dan menggunakan gorm:"autoUpdateTime:true" untuk UpdatedAt

field permission
- secara default, semua field di struct model akan dianggap kolom di table
- dan semua perubahan di field, akan di update ke tabel di database
- namun, kadang-kadang mungkin kita ingin membuat field yang tidak merepresentasikan kolom di tabel sehingga tidak perlu create / update
- atau mungkin terdapat kolom yang tidak perlu di update lagi
- untuk mendukung kasus seperti itu, GORM menyediakan field permission menggunakan tag gorm

    Tag     |   Keterangan
-----------------------------------------------------------------------------------------------------------------------------
    <-      |   Write permissio. <-:create (untuk create only), <-:update (untuk update only), <- (untuk create dan update)
    ->      |   Read permission. ->:false (untuk no read permission/tidak boleh dibaca)
    -       |   ignore field ini, tidak ada read/write permission

embedded struct
- secara default, field di model akan menjadi kolom tabel, kecuali yang menggunakan '-' (field permission ignore)
- namun, bagaimana jika ternyata field yang kita buat sangat banyak?
- kadang-kadang, ada baiknya kita simpan field yang sejenis dalam struct yang berbeda
- untungnya, GORM memiliki fitur bernama embedded struct, dimana kita bisa melakukan embed struct dalam field di model, sehingga seluruh isi field di embedded struct akan dianggap field di model utamanya
- misal, kita akan tambahkan kolom first_name, middle_name, dan last_name pada tabel users
- lalu kita akan buat dalam embedded struct Name
- kita bisa gunakan tag gorm:"embedded" untuk emnandai sebagai embedded struct

create
- untuk memasukkan data ke database, kita tidak perlu membuat SQL insert secara manual 
- GORM bisa membaca data dari model yang sudah kita buat, lalu secara otomatis akan membuat perintah SQL sesuai dengan data model yang kita buat
- kita bisa menggunakan method Create() pada gorm.DB

batch insert
- saat kita menggunakan Create() method, maka tiap data akan dibuatkan SQL insert
- kadang ketika kita ingin memasukkan banyak data sekaligus, ada baiknya kita menggunakan sekali SQl insert agar lebih efektif
- GORM mendukung hal ini menggunakan method Create(slices), atau jika ingin menentukan jumlah data per SQL insert, kita bisa gunakan CreateInBatches(slices, size)

logger
- secara default, informasi perintah SQL yang dieksekusi oleh GORM tidak akan di log
- kita bisa mengubah level log dari GORM menggunakan gorm.Config{} ketika membuat koneksi database

transaction
- transaction hanya bisa terjadi jika kita menggunakan database connection yang sama
- saat kita menggunakan method di gorm.DB, bisa saja tiap method akan menggunakan database connection yang berbeda, karena connection pool nya diatur oleh GORM
- jika kita ingin melakukan transaction, kita bisa menggunakan method Transaction(callback), dan di dalam function callback kita bisa buat semua kode transaction nya

manual transaction
- selain menggunakan method Transaction(callback), kita juga bisa melakukan manajemen transaksi secara manual (tidak direkomendasikan jika sudah menggunakan gorm)
- kita bisa membuat object gorm.DB ketika menjalankan transaksi dengan method Begin()
- ketika ingin melakukan commit, kita bisa menggunakan method Commit()
- ketika ingin melakukan rollback, kita bsia menggunakan method Rollback()

query 
- sama dengan Create(), GORM juga bisa secara otomatis membuat SQL SELECT dari model yang kita buat
- sehingga tidak perlu lagi membuat SQL select secara manual

single object
- GORM menyediakan beberapa method untuk mengambil single object dari database
- First() : digunakan untuk mengambil data pertama yang diurutkan berdasarkan id
- Take() : digunakan untuk mengambil satu data, tanpa di urutkan
- Last() : digunakan untuk mengambil data terakhir yang diurutkan berdasarkan id
- jika data tidak ditemukan, maka akan error gorm.ErrRecordNotFound

inline condition
- saat kita menggunakan method First, Take atau Last, terdapat parameter selanjutnya bernama inline condition
- inline condition tersebut secara otomatis akan menjadi kondisi WHERE di SQL SELECT nya

query all objects
- GORM juga bisa digunakan untuk melakukan QUERY pada semua data di tabel menggunakan method Find()
- sama seperti method sebelumnya, method Find() juga mendukung inline condition jika kita mau tambahkan kondisi WHERE nya

query condition
- sebelumnya kita sudah bisa menggunakan inline parameter ketika melakukan query
- selain menggunakan inline parameter, kita juga bisa menggunakan method Where() untuk mengubah kondisi query yang akan kita buat

or condition
- secara default saat kita menggunakan Where(), kondisi akan digabung menggunakan AND operator 
- jika kita ingin menggunakan OR operator, kita bisa menggunakan method OR()

not condition
- dan jika kita ingin menggunakan NOT operator, kita bisa menggunakan method NOT()

select Fields
- secara default, semua kolom akan di select dan dimasukkan ke field Model
- jika misal kita ingin menentukan kolom apa saja yang mau di select, kita bisa menggunakan method Select(columns)

struct & map condition
- saat kita menggunakan Where(), Not(), dan Or(). Kita juga bisa menggunakan parameter struct atau map
- secara otomatis field atau key dijadikan kolom query, dan value akan dijadikan value query
- ini cocok ketika pada kasus kita butuh query yang dinamis, sehingga kolom yang dicari bisa berbeda-beda sesuai kondisi pencarian

order, limit dan offset
- untuk melakukan sorting, kita juga bisa menggunakan method Order()
- dan untuk melakukan paging, kita bsia menggunakan method Limit() dan Offset()

query non model
- saat kita menggunakan First(), Take(), Last() dan Find(), GORM melihat struktur tabel ke model yang kita gunakan
- namun GORM memiliki fitur untuk menyimpan data (hasil query) ke data yang bukan model, contoh kita hanya ingin melakukan query first_name dan last_name saja di tabel users misalnya. kita bisa membuat struct berbeda dibanding menggunakan model users
- jika kita ingin melakukan hal ini, GORM tetap harus tahu, model mana yang digunakan, caranya adalah kita bisa menggunakan method Model() untuk menentukan model yang digunakan

update
- untuk melakukan update data model yang sudah dimodifikasi, kita bisa menggunakan method Save() di gorm.DB
- secara otomatis semua kolom yang memang memiliki permission untuk di update, akan di update ke database

update selected column
- secara default, melakukan Save() untuk data model, akan melakukan update semua kolom, walaupun tidak melakukan perubahan sebelumnya
- jika kita ingin menentukan hanya beberapa kolom yang ingin di update, kita bisa menggunakan method Updates()
- atau menggunakan method Update(kolom, value) jika hanya ingin update satu kolom saja

auto increment
- salah satu fitur yang biasa ada database adalah Auto Increment untuk primary key
- contoh di Mysql ada AUTO_INCREMENT, atau di PostgreSQL ada SERIAL
- GORM mendukung pembuatan ID yang auto increment, dan secara otomatis akan melakukan query data ID (data terakhir di database) setelah kita Create() datanya, sehingga tidak perlu melakukan query manual lagi
- untuk memberi tahu bahwa field adalah auto_increment, kita harus menggunakan tag gorm:"autoIncrement"

timestamp tracking
- GORM menggunakan field CreatedAt dan UpdatedAt sebagai timestamp tracking
- atau jika ingin menggunakan field yang berbeda, kita bisa tambahkan tag gorm:"autoCreateTime" atau gorm:"autoUpdateTime"

tipe data timestamp tracking
- sebelumnya kita menggunakan tipe data time.Time sebagai field untuk timestamp tracking 
- namun, sebenarnya kita juga bisa ubah tipe datanya jika kita mau
- GORM mendukung tipe data dalam bentuk number, dimana satuannya bisa kita ganti menjadi mili untuk mili second, atau nano untuk nano second, semuanya disimpan dalam waktu epoch unix time
- misal tag gorm:"autoCreateTime:mili" atau gorm:"autoUpdateTime:mili"
- referensi : https://currentmillis.com/

upsert 
- sebelumnya, kita telah menggunakan method Save() untuk melakukan update
- method Save(), sebenarnya memiliki kemampuan untuk mendeteksi apakah harus melakukan Update atau Create
- jika data yang kita kirim tidak memiliki value ID, maka secara default akan melakukan Create
- jika data yang kira kirim memiliki value ID, maka akan melakukan Update
- hal ini mungkin cocok untuk jenis data yang ID nya adalah Auto Increment, karena kita tidak butuh ID ketika melakukan create

upsert : data non auto increment
- untungnya, Save() juga bisa digunakan untuk proses otomatis Create
- jadi Save() akan mencoba melakukan update terlebih dahulu, ketika mendeteksi jumlah effectedRow nya adalah 0, secara otomatis method Save() akan melakukan proses Create

on conflict
- GORM juga menawarkan pengaturan conflict di method Create()
- dengan pengaturan ini, kita bisa menentukan ketika kita coba Create() data, lalu terjadi conflict (data sudah ada), apa yang mau kita lakukan?
- kita bisa mengubah pengaturan conflict ini menggunakan method Clauses()

delete
- untuk melakukan penghapusan data, kita bisa menggunakan method Delete()
- method Delete() juga mendukung Inline Condition atau menggunakan Where() method

soft delete
- soft delete adalah salah satu praktek yang sering dilakukan ketika membuat aplikasi
- soft delete merupakan praktek menghapus data, tanpa menghapus data dari database
- praktek ini membuat satu kolom biasanya berupa tipe data timestamp yang berisi waktu dihapus 
- jika kolom tersebut berisi data, otomatis data tersebut dianggap sudah di delete

GORM soft delete
- GORM mendukung fitur Soft Delete secara otomatis, caranya kita cukup membuat field DeletedAt dengan time gorm.DeletedAt (alias untuk time.Time)
- jika GORM mendeteksi terdapat field dengan nama DeletedAt, secara otomatis GORM akan melakukan soft delete
- selain itu, ketika melakukan query, secara otomatis juga GORM akan menambah filter soft delete, yang artinya hasil query hanya data yang belum di delete

unscoped
- ketika kita ingin mengambil data yang termasuk ke dalam soft delete, kita bisa gunakan method Unscoped()
- method Unscoped() juga bisa digunakan jika kita benar benar mau melakukan hard delete data secara permanen di database

soft delete - peringatan
- saat menggunakan soft delete, perhatikan penggunaan primary key atau unique index
- ketika data sudah dihapus secara soft delete, sebenarnya data masih ada di tabel, oleh karena itu pastikan primary key atau unique index tidak duplikat dengan data yang sudah dihapus secara soft delete

model struct
- GORM menyediakan sebuah struct bernama model yang berisi field ID, CreatedAt, UpdatedAt dan DeleteAt
- ini cocok digunakan ketika kita menggunakan field yang sesuai dengan convention nya GORM 
- contoh misal kita bisa gunakan struct model ini ketika membuat model Todo

lock
- hal yang biasa kita programmer lakukan saat menggunakan database adalah melakukan lock data
- biasanya, ini dilakukan agar tidak terjadi RACE CONDITION ketika memanipulasi data yang sama oleh beberapa request
- untuk melakukan lock menggunakan GORM, kita bisa menambahkan Clauses() Locking
- kita bisa menentukan jenis locknya, apakah itu UPDATE, SHARE atau yang lainnya. Sesuai dengan dukungan database yang kita gunakan

one to one
- relationship dalam database yang paling sederhana adalah one to one, dimana data di tabel berelasi dengan satu data di tabel lain
- di GORM, relasi one to one disebut juga relasi HasOne
- untuk membuat relasi one to one di model sangat mudah, kita cukup buat field dengan tipe model yang berelasi (foreign key)
- lalu kita bisa tambahkan informasi di tag
- gorm:"foreignKey:nama_kolom" : untuk kolom yang dijadikan foreign key
- gorm:"references:nama_kolom" : untuk kolom yang dijadikan reference

preload
- secara default, relasi tidak akan di query oleh GORM, artinya sifatnya adalah LAZY
- jika kita ingin melakukan query relation (EAGER) secara langsung ketika melakukan query model, kita bisa sebutkan relasi yang ingin kita load menggunakan method Preload()

join
- menggunakan Preload(), GORM akan melakukan pengambilan data relasi menggunakan query yang terpisah
- hal ini cocok ketika menggunakan relasi one to many atau many to many
- namun pada kasus one to one, kadang ada baiknya kita lakukan sekali query saja menggunakan JOIN, karena hasilnya hanya satu data, jadi proses nya lebih cepat
- jika kita ingin menggunakan join, kia bisa menggunakan method Joins(), lalu menyebutkan field mana yang akan kita lakukan JOIN

auto upsert relation (create/update)
- saat kita menggunakan relasi, lalu kita ingin melakukan create / update data Model, secara default GORM akan mengecek relasi yang terdapat di data tersebut
- jika terdapat relasi, GORM akan melakukan proses Upsert terhadap data relasinya, sehingga kita tidak perlu melakukan create / update data relasi secara manual

skip auto create / update
- jika kita tidak mau melakukan auto create / update data relasi, kita bisa gunakan method Omit() yang berisi clause.Associations
- dimana method ini akan memberi tahu GORM bahwa kita tidak mau melakukan auto create / update untuk data relasinya

one to many
- relasi one to many adalah relasi dimana data di tabel bisa memiliki relasi ke banyak data di tabel lain
- di GORM, one to many disebut relasi Has many
- untuk membuat relasi one to many, kita bisa gunakan field dengan tipe slice model yang berelasi 
- kita juga bisa menentukan informasi seperti foreignKey dan references nya, sama seperti ketika menggunakan relasi one to one

belongs to di one to many
- saat kita membuat relasi one to many, ada sudut pandang lain dari Model sebelahnya, yaitu relasi Many to one
- pada kasus ini, kita bisa menggunakan relasi Belongs To (milik) di GORM
- contoh sebelumnya kita tahu bahwa user punya banyak Address, artinya Address milik (belongs to) User
- kita bisa tambahkan relasi ini di Model Address, agar ketika kita melakukan query ke model Address, kita juga bisa mendapatkan informasi Usernya
- cara membuatnya, mirip seperti ketika membuat relasi one to one

belongs to di one to one
- selain di one to many, sebenarnya belongs to bisa di implementasikan di relasi one to one
- sebelumnya kita sudah tahu bahwa User punya satu (has one) Wallet, artinya wallet itu milik (belongs to) User
- kita bisa tambahkan field User di model Wallet sebagai relasi belongs to
- namun, karena di golang, cyclic itu tidak boleh, maka untuk menambahkan relasi belongs to di one to one, kita perlu menggunakan pointer
- cyclic : adalah konsep dimana struct satu (User) butuh struct lain (Wallet), dan struct lain (Wallet) tersebut butuh ke struct ke yang lain (User) dan seterusnya. Hal ini tidak diperbolehkan di golang

many to many
- relasi yang paling kompleks adalah relasi many to many
- seperti yang sudah kita ketahui, bahwa untuk relasi many to many, kita harus membuat tabel jembatan penghubung antara dua tabel
- GORM juga mendukung relasi many to many, caranya mudah kita hanya perlu membuat field berupa slice di kedua model yang berelasi
- untuk memberi tahu tabel penghubung dan juga kolom untuk join nya, kita bisa menggunakan tag

many to many tag
- untuk memberi tahu nama tabel penghubung, kita bisa menggunakan tag
gorm:"many2many:nama_tabel"
- saat melakukan query many to many, terdapat banyak sekali kolom yang perlu diketahui, seperti: 1. kolom id di Model pertama
2. kolom foreign key Model pertama di tabel penghubung
3. kolm id di Model kedua
4. kolom foreign key Model kedua di tabel penghubung

sehingga, semuanya bisa kita gunakan tag berikut :
1. gorm:"foreignKey:kolom_id" : untuk id di model pertama
2. gorm:"joinForeignKey:kolom_id" : untuk foreign key Model pertama di tabel penghubung
3. gorm:"foreignKey:kolom_id" : untuk id di model kedua
4. gorm:"joinForeignKey:kolom_id" : untuk foreign key Model kedua di tabel penghubung

contoh kasus (many to many)
- misal kita akan membuat fitur dimana user bisa like banyak product, dan satu product bisa di like banyak user
- artinya kita akan membuat model Product, lalu akan membuat relasi many to many antara user dan product

create / update / delete relasi many to many
- salah satu tantangan relasi many to many adalah, bagaimana cara melakukan create/update/delete relasi many to many
- hal ini karena tabel penghubung tidak memiliki representasi Model di GORM
- untungnya, GORM bisa digunakan untuk memanipulasi data, tanpa harus menggunakan Model
- kita bisa gunakan method Table() pada form.DB untuk menyebut tabel mana yang mau kita pilih
- walaupun cara ini bisa dilakukan, tapi sebenarnya cara yang lebih baik yaitu menggunakan fitur bernama Association Mode

